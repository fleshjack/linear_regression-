<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="doc.css" />
<title>Leveldb</title>
</head>

<body>
<h1>Leveldb</h1>
<address>Jeff Dean, Sanjay Ghemawat</address>
<p>
The <code>leveldb</code> library provides a persistent key value store.  Keys and
values are arbitrary byte arrays.  The keys are ordered within the key
value store according to a user-specified comparator function.

<p>
<h1>Opening A Database</h1>
<p>
A <code>leveldb</code> database has a name which corresponds to a file system
directory.  All of the contents of database are stored in this
directory.  The following example shows how to open a database,
creating it if necessary:
<p>
<pre>
  #include &lt;assert&gt;
  #include "leveldb/db.h"

  leveldb::DB* db;
  leveldb::Options options;
  options.create_if_missing = true;
  leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &amp;db);
  assert(status.ok());
  ...
</pre>
If you want to raise an error if the database already exists, add
the following line before the <code>leveldb::DB::Open</code> call:
<pre>
  options.error_if_exists = true;
</pre>
<h1>Status</h1>
<p>
You may have noticed the <code>leveldb::Status</code> type above.  Values of this
type are returned by most functions in <code>leveldb</code> that may encounter an
error.  You can check if such a result is ok, and also print an
associated error message:
<p>
<pre>
   leveldb::Status s = ...;
   if (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl;
</pre>
<h1>Closing A Database</h1>
<p>
When you are done with a database, just delete the database object.
Example:
<p>
<pre>
  ... open the db as described above ...
  ... do something with db ...
  delete db;
</pre>
<h1>Reads And Writes</h1>
<p>
The database provides <code>Put</code>, <code>Delete</code>, and <code>Get</code> methods to
modify/query the database.  For example, the following code
moves the value stored under key1 to key2.
<pre>
  std::string value;
  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);
  if (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);
  if (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);
</pre>

<h1>Atomic Updates</h1>
<p>
Note that if the process dies after the Put of key2 but before the
delete of key1, the same value may be left stored under multiple keys.
Such problems can be avoided by using the <code>WriteBatch</code> class to
atomically apply a set of updates:
<p>
<pre>
  #include "leveldb/write_batch.h"
  ...
  std::string value;
  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);
  if (s.ok()) {
    leveldb::WriteBatch batch;
    batch.Delete(key1);
    batch.Put(key2, value);
    s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);
  }
</pre>
The <code>WriteBatch</code> holds a sequence of edits to be made to the database,
and these edits within the batch are applied in order.  Note that we
called <code>Delete</code> before <code>Put</code> so that if <code>key1</code> is identical to <code>key2</code>,
we do not end up erroneously dropping the value entirely.
<p>
Apart from its atomicity benefits, <code>WriteBatch</code> may also be used to
speed up bulk updates by placing lots of individual mutations into the
same batch.

<h1>Synchronous Writes</h1>
By default, each write to <code>leveldb</code> is asynchronous: it
returns after pushing the write from the process into the operating
system.  The transfer from operating system memory to the underlying
persistent storage happens asynchronously.  The <code>sync</code> flag
can be turned on for a particular write to make the write operation
not return until the data being written has been pushed all the way to
persistent storage.  (On Posix systems, this is implemented by calling
either <code>fsync(...)</code> or <code>fdatasync(...)</code> or
<code>msync(..., MS_SYNC)</code> before the write operation returns.)
<pre>
  leveldb::WriteOptions write_options;
  write_options.sync = true;
  db-&gt;Put(write_options, ...);
</pre>
Asynchronous writes are often more than a thousand times as fast as
synchronous writes.  The downside of asynchronous writes is that a
crash of the machine may cause the last few updates to be lost.  Note
that a crash of just the writing process (i.e., not a reboot) will not
cause any loss since even when <code>sync</code> is false, an update
is pushed from the process memory into the operating system before it
is considered done.

<p>
Asynchronous writes can often be used safely.  For example, when
loading a large amount of data into the database you can handle lost
updates by restarting the bulk load after a crash.  A hybrid scheme is
also possible where every Nth write is synchronous, and in the event
of a crash, the bulk load is restarted just after the last synchronous
write finished by the previous run.  (The synchronous write can update
a marker that describes where to restart on a crash.)

<p>
<code>WriteBatch</code> provides an alternative to asynchronous writes.
Multiple updates may be placed in the same <code>WriteBatch</code> and
applied together using a synchronous write (i.e.,
<code>write_options.sync</code> is set to true).  The extra cost of
the synchronous write will be amortized across all of the writes in
the batch.

<p>
<h1>Concurrency</h1>
<p>
A database may only be opened by one process at a time.
The <code>leveldb</code> implementation acquires a lock from the
operating system to prevent misuse.  Within a single process, the
same <code>leveldb::DB</code> object may be safely shared by multiple
concurrent threads.  I.e., different threads may write into or fetch
iterators or call <code>Get</code> on the same database without any
external synchronization (the leveldb implementation will
automatically do the required synchronization).  However other objects
(like Iterator and WriteBatch) may require external synchronization.
If two threads share such an object, they must protect access to it
using their own locking protocol.  More details are available in
the public header files.
<p>
<h1>Iteration</h1>
<p>
The following example demonstrates how to print all key,value pairs
in a database.
<p>
<pre>
  leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());
  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {
    cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; ": "  &lt;&lt; it-&gt;value().ToString() &lt;&lt; endl;
  }
  assert(it-&gt;status().ok());  // Check for any errors found during the scan
  delete it;
</pre>
The following variation shows how to process just the keys in the
range <code>[start,limit)</code>:
<p>
<pre>
  for (it-&gt;Seek(start);
       it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;
       it-&gt;Next()) {
    ...
  }
</pre>
You can also process entries in reverse order.  (Caveat: reverse
iteration may be somewhat slower than forward iteration.)
<p>
<pre>
  for (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) {
    ...
  }
</pre>
<h1>Snapshots</h1>
<p>
Snapshots provide consistent read-only views over the entire state of
the key-value store.  <code>ReadOptions::snapshot</code> may be non-NULL to indicate
that a read should operate on a particular version of the DB state.
If <code>ReadOptions::snapshot</code> is NULL, the read will operate on an
implicit snapshot of the current state.
<p>
Snapshots are created by the DB::GetSnapshot() method:
<p>
<pre>
  leveldb::ReadOptions options;
  options.snapshot = db-&gt;GetSnapshot();
  ... apply some updates to db ...
  leveldb::Iterator* iter = db-&gt;NewIterator(options);
  ... read using iter to view the state when the snapshot was created ...
  delete iter;
  db-&gt;ReleaseSnapshot(options.snapshot);
</pre>
Note that when a snapshot is no longer needed, it should be released
using the DB::ReleaseSnapshot interface.  This allows the
implementation to get rid of state that was being maintained just to
support reading as of that snapshot.
<h1>Slice</h1>
<p>
The return value of the <code>it->key()</code> and <code>it->value()</code> calls above
are instances of the <code>leveldb::Slice</code> type.  <code>Slice</code> is a simple
structure that contains a length and a pointer to an external byte
array.  Returning a <code>Slice</code> is a cheaper alternative to returning a
<code>std::string</code> since we do not need to copy potentially large keys and
values.  In addition, <code>leveldb</code> methods do not return null-terminated
C-style strings since <code>leveldb</code> keys and values are allowed to
contain '\0' bytes.
<p>
C++ strings and null-terminated C-style strings can be easily converted
to a Slice:
<p>
<pre>
   leveldb::Slice s1 = "hello";

   std::string str("world");
   leveldb::Slice s2 = str;
</pre>
A Slice can be easily converted back to a C++ string:
<pre>
   std::string str = s1.ToString();
   assert(str == std::string("hello"));
</pre>
Be careful when using Slices since it is up to the caller to ensure that
the external byte array into which the Slice points remains live while
the Slice is in use.  For example, the following is buggy:
<p>
<pre>
   leveldb::Slice slice;
   if (...) {
     std::string str = ...;
     slice = str;
   }
   Use(slice);
</pre>
When the <code>if</code> statement goes out of scope, <code>str</code> will be destroyed and the
backing storage for <code>slice</code> will disappear.
<p>
<h1>Comparators</h1>
<p>
The preceding examples used the default ordering function for key,
which orders bytes lexicographically.  You can however supply a custom
comparator when opening a database.  For example, suppose each
database key consists of two numbers and we should sort by the first
number, breaking ties by the second number.  First, define a proper
subclass of <code>leveldb::Comparator</code> that expresses these rules:
<p>
<pre>
  class TwoPartComparator : public leveldb::Comparator {
   public:
    // Three-way comparison function:
    //   if a &lt; b: negative result
    //   if a &gt; b: positive result
    //   else: zero result
    int Compare(const leveldb::Slice&amp; a, const leveldb::Slice&amp; b) const {
      int a1, a2, b1, b2;
      ParseKey(a, &amp;a1, &amp;a2);
      ParseKey(b, &amp;b1, &amp;b2);
      if (a1 &lt; b1) return -1;
      if (a1 &gt; b1) return +1;
      if (a2 &lt; b2) return -1;
      if (a2 &gt; b2) return +1;
      return 0;
    }

    // Ignore the following methods for now:
    const char* Name() const { return "TwoPartComparator"; }
    void FindShortestSeparator(std::string*, const leveldb::Slice&amp;) const { }
    void FindShortSuccessor(std::string*) const { }
  };
</pre>
Now create a database using this custom comparator:
<p>
<pre>
  TwoPartComparator cmp;
  leveldb::DB* db;
  leveldb::Options options;
  options.create_if_missing = true;
  options.comparator = &amp;cmp;
  leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &amp;db);
  ...
</pre>
<h2>Backwards compatibility</h2>
<p>
The result of the comparator's <code>Name</code> method is attached to the
database when it is created, and is checked on every subsequent
database open.  If the name changes, the <code>leveldb::DB::Open</code> call will
fail.  Therefore, change the name i